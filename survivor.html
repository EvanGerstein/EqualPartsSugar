<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Night Fry Survivors</title>
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; background: radial-gradient(circle at top, #151533, #080812 65%); color: #f6f6ff; font-family: Arial, sans-serif; overflow: hidden; }
    .ui {
      position: fixed; inset: 0; pointer-events: none;
      display: flex; flex-direction: column; justify-content: space-between;
      padding: 12px;
    }
    .topbar { display: flex; gap: 10px; flex-wrap: wrap; }
    .pill { background: rgba(8,10,30,.75); border: 1px solid #8cc8ff; color: #dff4ff; padding: 6px 10px; border-radius: 999px; font-weight: 700; font-size: 14px; }
    .hint { opacity: .9; }
    .levelup {
      position: fixed; inset: 0; background: rgba(5,5,20,.82); display: none;
      align-items: center; justify-content: center; z-index: 10;
    }
    .levelup.show { display: flex; }
    .panel { width: min(980px, 94vw); background: linear-gradient(180deg,#151a3a,#0e122a); border: 2px solid #f4c22d; border-radius: 16px; padding: 18px; box-shadow: 0 20px 40px rgba(0,0,0,.5); }
    .panel h2 { margin: 0 0 12px; color: #ffe08a; }
    .choices { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }
    .choice { pointer-events: auto; background: linear-gradient(180deg,#1a2350,#121938); border: 2px solid #70c0ff; border-radius: 12px; padding: 10px; cursor: pointer; min-height: 130px; }
    .choice:hover { transform: translateY(-2px); }
    .choice h3 { margin: 0 0 4px; font-size: 18px; color: #9ce7ff; }
    .choice p { margin: 0; font-size: 13px; opacity: .95; }
    .legend { pointer-events: auto; font-size: 13px; opacity: .9; text-align: right; }
    a.home { color: #ffe08a; text-decoration: none; }
    #game { display:block; }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div class="ui">
    <div class="topbar">
      <div class="pill">ü¶á Night Fry Survivors</div>
      <div class="pill" id="time">Time: 0s</div>
      <div class="pill" id="score">Score: 0</div>
      <div class="pill" id="wave">Threat: 1</div>
      <div class="pill" id="health">HP: 100</div>
      <div class="pill" id="xp">XP: 0 / 8</div>
      <div class="pill"><a class="home" href="index.html">‚Üê Home</a></div>
    </div>
    <div class="legend hint">WASD move ‚Ä¢ mouse aim ‚Ä¢ hold click to fire ‚Ä¢ survive and stack powerups</div>
  </div>

  <div class="levelup" id="levelup">
    <div class="panel">
      <h2>Level Up ‚Äî Pick your dopamine</h2>
      <div class="choices" id="choices"></div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const ui = {
      time: document.getElementById('time'), score: document.getElementById('score'), wave: document.getElementById('wave'),
      health: document.getElementById('health'), xp: document.getElementById('xp')
    };
    const levelupEl = document.getElementById('levelup');
    const choicesEl = document.getElementById('choices');

    const keys = {};
    const mouse = {x: 0, y: 0, down: false};

    function resize() { canvas.width = innerWidth; canvas.height = innerHeight; }
    addEventListener('resize', resize); resize();

    addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
    addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
    addEventListener('mousedown', () => mouse.down = true);
    addEventListener('mouseup', () => mouse.down = false);

    const rand = (a,b)=>Math.random()*(b-a)+a;
    const choose = arr => arr[(Math.random()*arr.length)|0];

    const state = {
      running: true,
      t: 0,
      score: 0,
      threat: 1,
      xp: 0,
      level: 1,
      xpNeed: 8,
      spawnTimer: 0,
      particles: [],
      bullets: [],
      enemies: [],
      drops: [],
      flashes: 0,
      shake: 0,
      abilities: {},
      abilityCatalog: [],
      fusions: [],
      player: {x: canvas.width/2, y: canvas.height/2, r: 16, speed: 260, hp: 100, maxHp:100, fireCd:0, fireRate:8, damage:15, bulletSpeed:520, projCount:1}
    };

    const abilityPrefixes = ['Quantum','Blood','Hyper','Neon','Void','Arc','Turbo','Solar','Frost','Echo'];
    const abilityRoots = ['Burst','Shards','Spiral','Lance','Mine','Orbit','Comet','Nova','Pulse','Rift'];
    const abilityStyles = ['crit', 'firerate', 'damage', 'speed', 'multishot'];

    function generateAbilities() {
      const list = [];
      for (let i=0;i<20;i++) {
        const name = `${choose(abilityPrefixes)} ${choose(abilityRoots)}`;
        const style = choose(abilityStyles);
        list.push({ id:`a${i}`, name, style, tier:1,
          desc: style==='damage'?'Shots hit harder':style==='firerate'?'Shoot faster':style==='speed'?'Move faster':style==='multishot'?'Extra projectiles':'Critical bursts explode'
        });
      }
      state.abilityCatalog = list;
      state.fusions = [
        { need:['damage','multishot'], id:'fusion_blender', name:'Blender Storm', desc:'Shotguns of spinning death', apply: ()=>{state.player.projCount += 2; state.player.damage += 7;}},
        { need:['firerate','speed'], id:'fusion_dashgun', name:'Dash Barrage', desc:'Movement feeds fire rate', apply: ()=>{state.player.fireRate += 2; state.player.speed += 25;}},
        { need:['crit','damage'], id:'fusion_overclock', name:'Overclock Rupture', desc:'Critical hits pop into novas', apply: ()=>{state.player.damage += 10; state.shake += 4;}}
      ];
    }

    function enemyTemplate() {
      const t = state.t;
      const pick = Math.random();
      if (pick < 0.6) return { type:'chaser', r:14, hp:26 + t*0.8, speed:80 + t*0.35, color:'#ff5e79', dmg:8 };
      if (pick < 0.85) return { type:'tank', r:22, hp:55 + t*1.4, speed:48 + t*0.25, color:'#a88bff', dmg:12 };
      return { type:'shooter', r:16, hp:34 + t, speed:62 + t*0.3, color:'#59d9ff', dmg:9, shootCd:rand(.8,1.6) };
    }

    function spawnEnemy() {
      const e = enemyTemplate();
      const side = (Math.random()*4)|0;
      let x=0,y=0;
      if(side===0){x=-30;y=rand(0,canvas.height);} if(side===1){x=canvas.width+30;y=rand(0,canvas.height);} if(side===2){x=rand(0,canvas.width);y=-30;} if(side===3){x=rand(0,canvas.width);y=canvas.height+30;}
      state.enemies.push({...e,x,y,vx:0,vy:0});
    }

    function shootAt(tx,ty,spread=0) {
      const p = state.player;
      const base = Math.atan2(ty-p.y, tx-p.x);
      const count = p.projCount;
      for(let i=0;i<count;i++) {
        const a = base + (i-(count-1)/2)*0.12 + rand(-spread,spread);
        state.bullets.push({x:p.x,y:p.y,vx:Math.cos(a)*p.bulletSpeed,vy:Math.sin(a)*p.bulletSpeed,r:5,life:1.8, dmg:p.damage});
      }
    }

    function gainXp(n) {
      state.xp += n;
      while(state.xp >= state.xpNeed) {
        state.xp -= state.xpNeed;
        state.level++;
        state.xpNeed = Math.floor(state.xpNeed * 1.24 + 2);
        openLevelUp();
      }
    }

    function applyAbility(ab) {
      state.abilities[ab.style] = (state.abilities[ab.style]||0) + 1;
      if (ab.style==='damage') state.player.damage += 4;
      if (ab.style==='firerate') state.player.fireRate += 1.1;
      if (ab.style==='speed') state.player.speed += 14;
      if (ab.style==='multishot') state.player.projCount = Math.min(7, state.player.projCount + 1);
      if (ab.style==='crit') state.player.damage += 2;
      checkFusion();
    }

    function checkFusion() {
      for (const f of state.fusions) {
        if (state.abilities[f.id]) continue;
        const ok = f.need.every(s => (state.abilities[s]||0) >= 2);
        if (ok) {
          state.abilities[f.id] = 1;
          f.apply();
          floatingText(state.player.x, state.player.y-30, `FUSION: ${f.name}!`, '#ffe08a', 1.3);
          state.flashes = 1;
          state.shake += 10;
        }
      }
    }

    function abilityChoices() {
      const picks = [];
      while (picks.length < 3) {
        const candidate = choose(state.abilityCatalog);
        if (!picks.includes(candidate)) picks.push(candidate);
      }
      return picks;
    }

    function openLevelUp() {
      state.running = false;
      levelupEl.classList.add('show');
      choicesEl.innerHTML = '';
      abilityChoices().forEach(ab => {
        const b = document.createElement('button');
        b.className = 'choice';
        b.innerHTML = `<h3>${ab.name}</h3><p>${ab.desc}</p><p><b>Type:</b> ${ab.style}</p>`;
        b.onclick = () => {
          applyAbility(ab);
          levelupEl.classList.remove('show');
          state.running = true;
        };
        choicesEl.appendChild(b);
      });
    }

    function floatingText(x,y,text,color='#fff',scale=1) {
      state.particles.push({type:'text',x,y,text,color,life:1.2,vy:-30,scale});
    }

    function boom(x,y,color='#fff') {
      for(let i=0;i<12;i++){
        const a=rand(0,Math.PI*2), sp=rand(40,240);
        state.particles.push({type:'spark',x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:rand(.25,.8),color,r:rand(2,5)});
      }
    }

    function update(dt) {
      const p = state.player;
      state.t += dt;
      state.threat = 1 + Math.floor(state.t/25);
      state.spawnTimer -= dt;
      if (state.spawnTimer <= 0) {
        const count = 1 + Math.floor(state.t/18);
        for(let i=0;i<count;i++) spawnEnemy();
        state.spawnTimer = Math.max(.22, 1.1 - state.t*0.01);
      }

      let dx = (keys['d']?1:0) - (keys['a']?1:0);
      let dy = (keys['s']?1:0) - (keys['w']?1:0);
      const mag = Math.hypot(dx,dy) || 1;
      p.x += (dx/mag) * p.speed * dt;
      p.y += (dy/mag) * p.speed * dt;
      p.x = Math.max(p.r, Math.min(canvas.width-p.r, p.x));
      p.y = Math.max(p.r, Math.min(canvas.height-p.r, p.y));

      p.fireCd -= dt;
      if (mouse.down && p.fireCd <= 0) {
        shootAt(mouse.x, mouse.y, 0.07);
        p.fireCd = 1/p.fireRate;
      }

      for (const b of state.bullets) {
        b.x += b.vx*dt; b.y += b.vy*dt; b.life -= dt;
      }
      state.bullets = state.bullets.filter(b => b.life>0 && b.x>-50 && b.x<canvas.width+50 && b.y>-50 && b.y<canvas.height+50);

      for (const e of state.enemies) {
        const ang = Math.atan2(p.y-e.y,p.x-e.x);
        e.vx = Math.cos(ang)*e.speed; e.vy = Math.sin(ang)*e.speed;
        e.x += e.vx*dt; e.y += e.vy*dt;
        if (e.type==='shooter') {
          e.shootCd -= dt;
          if (e.shootCd <= 0) {
            e.shootCd = rand(1.0,2.0) - Math.min(0.5,state.t*0.002);
            const a = Math.atan2(p.y-e.y,p.x-e.x);
            state.enemies.push({type:'enemyBullet',x:e.x,y:e.y,r:5,hp:1,speed:230 + state.t,color:'#ffdd88',vx:Math.cos(a)*(230+state.t),vy:Math.sin(a)*(230+state.t),dmg:7});
          }
        }
      }

      for (const e of state.enemies) {
        if (e.type==='enemyBullet') { e.x += e.vx*dt; e.y += e.vy*dt; }
      }

      // collisions
      for (const b of state.bullets) {
        for (const e of state.enemies) {
          if (e.type==='enemyBullet') continue;
          const d = Math.hypot(b.x-e.x,b.y-e.y);
          if (d < b.r + e.r) {
            e.hp -= b.dmg;
            b.life = 0;
            boom(b.x,b.y,'#9ce7ff');
            if (e.hp <= 0) {
              state.score += 10;
              if (Math.random() < 0.55) state.drops.push({x:e.x,y:e.y,r:8,val:1+Math.floor(state.t/40),life:10});
              boom(e.x,e.y,e.color);
              floatingText(e.x,e.y-8,'+10','#ffe08a',1);
              e.dead = true;
              state.shake += 1.8;
            }
          }
        }
      }

      for (const e of state.enemies) {
        if (e.dead) continue;
        const d = Math.hypot(p.x-e.x,p.y-e.y);
        if (d < p.r + e.r) {
          if (e.type === 'enemyBullet') { p.hp -= e.dmg*dt*2.5; e.dead=true; }
          else p.hp -= e.dmg * dt;
          state.shake += .3;
        }
      }

      state.enemies = state.enemies.filter(e => !e.dead && e.x>-120 && e.x<canvas.width+120 && e.y>-120 && e.y<canvas.height+120);

      for (const d of state.drops) {
        d.life -= dt;
        const dist = Math.hypot(p.x-d.x,p.y-d.y);
        if (dist < 130) {
          d.x += (p.x-d.x)*dt*3.2;
          d.y += (p.y-d.y)*dt*3.2;
        }
        if (dist < p.r + d.r + 2) {
          gainXp(d.val);
          state.score += 5;
          floatingText(d.x,d.y,'XP!','#9ce7ff',.9);
          d.dead = true;
        }
      }
      state.drops = state.drops.filter(d=>!d.dead && d.life>0);

      for (const pa of state.particles) {
        pa.life -= dt;
        if (pa.type==='spark') { pa.x += pa.vx*dt; pa.y += pa.vy*dt; pa.vx*=0.96; pa.vy*=0.96; }
        else { pa.y += pa.vy*dt; }
      }
      state.particles = state.particles.filter(pa=>pa.life>0);

      if (p.hp <= 0) {
        state.running = false;
        levelupEl.classList.add('show');
        choicesEl.innerHTML = `<div class='choice' style='grid-column:1/-1;pointer-events:none'><h3>Game Over</h3><p>You lasted ${Math.floor(state.t)}s ‚Ä¢ Score ${state.score}</p><p>Refresh to run it back üî•</p></div>`;
      }
    }

    function draw() {
      const shakeMag = state.shake;
      state.shake *= 0.88;
      const sx = rand(-shakeMag, shakeMag), sy = rand(-shakeMag, shakeMag);

      ctx.save();
      ctx.translate(sx, sy);
      ctx.clearRect(-100,-100,canvas.width+200,canvas.height+200);

      // arena grid
      ctx.globalAlpha = 0.2;
      ctx.strokeStyle = '#9ec8ff';
      for (let x=0; x<canvas.width; x+=60){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,canvas.height);ctx.stroke();}
      for (let y=0; y<canvas.height; y+=60){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(canvas.width,y);ctx.stroke();}
      ctx.globalAlpha = 1;

      for (const d of state.drops) {
        ctx.fillStyle='#ffe08a';
        ctx.beginPath();ctx.arc(d.x,d.y,d.r,0,Math.PI*2);ctx.fill();
      }

      for (const b of state.bullets) {
        ctx.fillStyle = '#9ce7ff';
        ctx.beginPath();ctx.arc(b.x,b.y,b.r,0,Math.PI*2);ctx.fill();
      }

      for (const e of state.enemies) {
        ctx.fillStyle = e.color || '#fff';
        ctx.beginPath();ctx.arc(e.x,e.y,e.r,0,Math.PI*2);ctx.fill();
      }

      const p = state.player;
      const ang = Math.atan2(mouse.y-p.y, mouse.x-p.x);
      ctx.save();
      ctx.translate(p.x,p.y); ctx.rotate(ang);
      ctx.fillStyle = '#4dd3ff';
      ctx.beginPath(); ctx.arc(0,0,p.r,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#ffe08a';
      ctx.fillRect(6,-4,18,8);
      ctx.restore();

      for (const pa of state.particles) {
        if (pa.type==='spark') {
          ctx.globalAlpha = Math.max(0, pa.life);
          ctx.fillStyle = pa.color;
          ctx.beginPath();ctx.arc(pa.x,pa.y,pa.r,0,Math.PI*2);ctx.fill();
          ctx.globalAlpha = 1;
        } else {
          ctx.globalAlpha = Math.max(0, pa.life);
          ctx.fillStyle = pa.color;
          ctx.font = `${14*(pa.scale||1)}px Arial`;
          ctx.fillText(pa.text, pa.x, pa.y);
          ctx.globalAlpha = 1;
        }
      }

      if (state.flashes > 0) {
        ctx.fillStyle = `rgba(255,255,200,${Math.min(0.35,state.flashes)})`;
        ctx.fillRect(0,0,canvas.width,canvas.height);
        state.flashes -= 0.03;
      }

      ctx.restore();

      ui.time.textContent = `Time: ${Math.floor(state.t)}s`;
      ui.score.textContent = `Score: ${state.score}`;
      ui.wave.textContent = `Threat: ${state.threat}`;
      ui.health.textContent = `HP: ${Math.max(0,Math.floor(state.player.hp))}`;
      ui.xp.textContent = `XP: ${state.xp} / ${state.xpNeed}`;
    }

    generateAbilities();

    let last = performance.now();
    function loop(now) {
      const dt = Math.min(0.033,(now-last)/1000); last=now;
      if (state.running) update(dt);
      draw();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
